
options {
    STATIC = false;
    //**AGREGUE UNA OPCION QUE ME PERMITE NO TOMARLE IMPORTANCIA MAYUSCULAS Y MINUSCULAS
    IGNORE_CASE = true;
}

PARSER_BEGIN(Pseasy)
package src;
import java.util.ArrayList;
import src.TablaIdentificadores;
import src.ArchivoCodigoIntermedio;
import src.GeneradorCodigo;
public class Pseasy {

        static ArrayList<String> tabla = PseasyTokenManager.tabla;



        public static void main(String[] args) {
            try{
                Pseasy pseasy = new Pseasy(System.in);
                pseasy.programa();

                if(tabla.size() != 0){
                    System.out.println("PROGRAM ERRORS");
                    System.out.println("=================");
                    for(String i:tabla){
                        System.out.println(i);
                    }
                }else{
                    System.out.println("\ncompilation generated with success");
                    //Aqui generar el archivo con el codigo intermedio
                    ArchivoCodigoIntermedio codigoIntermedio = new ArchivoCodigoIntermedio("codigoIntermedio");

                    //Se escribe las sentencias de codigo intermedio almacenadas en el arreglo representacionIntermedia
                    codigoIntermedio.escribirArchivo(GeneradorCodigo.representacionIntermedia);
                }
              }catch(Exception e){
                System.out.println(e.getMessage());
              }
          }

          //Metodos para generar las sentencias de codigo intermedio


        }
PARSER_END(Pseasy)

TOKEN_MGR_DECLS:{
    static ArrayList<String> tabla = new ArrayList();

}

// Inicio y fin del programa
TOKEN : {
    <INICIO: "Algoritmo">
    |
    <FIN: "FinAlgoritmo">
}

// Tipos de dato
TOKEN : {

    <ENTERO: "entero">
    |
    <FLOTANTE:"flotante">
    |
    <CADENA:"cadena">
    |
    <CARACTER:"caracter">
    |
    <BOOLEANO:"booleano">
}


// Constantes/Literales
TOKEN : {
    <#LETRA: ["a" - "z"] | ["A" - "Z"]>
    |
    <#NUMERO: ["0" - "9"]>
    |
    <CADENA_TEXTO: "\"" ( ~["\""] )* "\"">
    |
    <CARACTER_TEXTO: "'"( ~["'"] | "" )"'">
    |
    <NUMERO_ENTERO:("-" | "" | "+")(<NUMERO>)+>
    |
    <NUMERO_DECIMAL: ("-" | "" | "+")(<NUMERO>)+"."(<NUMERO>)+>
    |
    <BOOLEANO_FALSO: "Falso">
    |
    <BOOLEANO_VERDADERO: "Verdadero">
    |
    <DELIMITADOR: ";">
    |
    <COMA:","> //Coma

}

// Escritura, Lectura y Definici√≥n de variables
TOKEN : {
    <LEER: "Leer">
    |
    <ESCRIBIR: "Escribir">
    |
    <DEFINIR: "Definir">
}

// Operadores
TOKEN : {
    <ASIGNACION: "=">
    |
    <SUMA: "+">
    |
    <RESTA: "-">
    |
    <MULTIPLICACION: "*">
    |
    <DIVISION: "/">
    |
    <MODULO: "%">
    |
    <LOGICO_AND: "&&">
    |
    <LOGICO_OR: "||">
    |
    <LOGICO_NOT: "!">
    |
    <ASIGNACION_COMPUESTA: (<SUMA>|<RESTA>|<MULTIPLICACION>|<DIVISION>|<MODULO>|<LOGICO_AND>|<LOGICO_OR>)<ASIGNACION>>
    |
    <OPERADOR_IGUAL: "==">
    |
    <OPERADOR_DIFERENTE: "!=">
    |
    <OPERADOR_MAYOR: ">">
    |
    <OPERADOR_MENOR: "<">
    |
    <OPERADOR_MAYOR_IGUAL: ">=">
    |
    <OPERADOR_MENOR_IGUAL: "<=">
    |
    <OPERADOR_DOS_PUNTOS: ":">
    |
    <PAREN_ABIERTO: "(">
    |
    <PAREN_CERRADO: ")">
}

// Ciclos
TOKEN : {
    <INICIO_CICLO_PARA: "Para">
    |
    <CONDICION_CICLO_PARA: "Hasta que">
    |
    <INCREMENTO_CICLO_PARA: "incremento">
    |
    <DECREMENTO_CICLO_PARA:"decremento">
    |
    <FIN_CICLO_PARA: "FinPara">
    |
    <INICIO_CICLO_MIENTRAS: "Mientras">
    |
    <FIN_CICLO_MIENTRAS: "FinMientras">
    |
    <INICIO_CICLO_REPETIR: "Repetir">
    |
    <CONDICION_CICLO_REPETIR: "Finaliza cuando">
}

// Condicionales
TOKEN : {
    <INICIO_CONDICIONAL_SI:"Si">
    |
    <ENTONCES:"Entonces">
    |
    <CONDICIONAL_SINO:"Sino">
    |
    <FIN_CONDICIONAL_SI:"FinSi">
    |
    <INICIO_CONDICIONAL_SEGUN:"Segun">
    |
    <CASO:"Caso">
    |
    <CASO_PREDETERMINADO:"En otro caso">
    |
    <FIN_SEGUN:"FinSegun">
    |
    <HACER : "Hacer">
}

//Variables
TOKEN : {
    <VARIABLE:(<LETRA> | "_")(<NUMERO> | <LETRA> | "_")*>
    /*
    * IDENTIFICADORES NO VALIDOS
    * */
}

SKIP : {
    " "
    | "\t"
    | "\r\n"
    | "\n"
    | <COMENTARIO: "#" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
    //Tokens invalidos
    |<ID_INVALIDO:(<NUMERO>)+(<LETRA>|<NUMERO>)+>{tabla.add("Lexical error at line:" + input_stream.getBeginLine() + " column:" + input_stream.getBeginColumn() +
                                                                     " invalid id:" + image);}
    | <INVALIDO: ~[]>{tabla.add("Lexical error at line:" + input_stream.getBeginLine() + " column:" + input_stream.getBeginColumn() +
                    "invalid token:" + image);}
}

// Gramaticas

//CAMBIO: Nuestro programa puede no tener sentencias entre Algoritmo y FinAlgoritmo
void programa(): { }{

       try{
          <INICIO>
          ( sentencias() )*
          <FIN>{//TablaIdentificadores.mostrarTabla();
       }
       }catch(ParseException e){
            Token t;
            do{
                t=getNextToken();
            }while(t.kind != EOF);


            tabla.add("Parser Error:" + e.getMessage());
       }

}

void sentencias():{
    TablaIdentificadores.inicializarTipos();
 }{

            sentenciaAsignacion() |
            sentenciaDeclaracionVariables() |
            leerDato() |
            imprimirDato() |
            sentenciaSi() |
            sentenciaSegun() |
            sentenciaPara() |
            sentenciaRepetir() |
            sentenciaMientras()



}
//ASIGNACION DE VALOR
//Aqui hay un problema
void sentenciaAsignacion():{
    Token identificador = new Token();
    Token asignado = new Token();
 }{
    try{

        <VARIABLE> {
                        //EXISTENCIA DE IDENTIFICADORES
                        // Sino existe el id, lo guardamos en nuestra arreglo de errores
                        //System.out.println("Token:" + token);
                         if(!TablaIdentificadores.checkExistenciaId(token)){
                               tabla.add("The indentifier: " + token.image + " doesn't exist, at line:" +
                                       token.beginLine + " column:" + token.beginColumn);
                         }else{
                            identificador = token;

                         }
        }
        //Aqui se guarda 10
        //Con el cambio se guardaria t1
        asignado=asignacion() { //Se evalua si se esta asignando el tipo correcto al identificador
                        if(asignado.kind !=0 && identificador.kind !=0){ //Con esta sentencia comprobamos que el elemento asignado no sea null
                            //Si existe el identificador comprobamos su tipo
                                if(!TablaIdentificadores.verifiacionConToken(identificador,asignado)){

                                    tabla.add("The token: " + asignado.image + " doesn't correspond to the " +
                                            TablaIdentificadores.obtenerTipo(identificador) + " type");
                                //Si la expresion es semanticamente correcta, lo guardamos en nuestro arreglo de representacion intermedia
                                }else{
                                    GeneradorCodigo.asignacion(identificador.image,GeneradorCodigo.obtenerUltimoTemporal());
                                }

                        }


        }
        <DELIMITADOR>

    }catch(ParseException e){
        //System.out.println(e.toString());
        Token t;
        do{
            t=getNextToken();
        }while(t.kind != DELIMITADOR && t.kind != EOF);
        tabla.add("Parser error:" + e.getMessage());
    }
}

//Probar manejo de errores
void sentenciaDeclaracionVariables():{}{
    try{
        (declaracionVariables() <DELIMITADOR>)

    }catch(ParseException e){
            //System.out.println(e.toString());
            Token t;
            do{
                t=getNextToken();
                //VERIFICAR ERROR DE PUNTO Y COMA AL FINAL
            }while(t.kind != DELIMITADOR && t.kind != EOF);
            tabla.add("Parser error:" + e.getMessage());
    }
}


//CAMBIAMOS el tipo de dato retornado a token
Token constantes():{ }{
    <NUMERO_ENTERO> {return token;}
    | <NUMERO_DECIMAL>  {return token;}
    | <CADENA_TEXTO> {return token;}
    | <CARACTER_TEXTO> {return token;}
    | <BOOLEANO_FALSO> {return token;}
    | <BOOLEANO_VERDADERO> {return token;}
}

//ASIGNACION CORRECTA DE VALORES
Token asignacion():{Token asignado = new Token();}{
    ( <ASIGNACION> | <ASIGNACION_COMPUESTA> ) asignado=condicion() {return asignado;}
}

Token condicion():{Token asignado = new Token();} {
    asignado=operacion() {return asignado;}
    ( operadoresRelacionales() operacion() )*
}


Token operacion():{
    Token t = new Token();
    Token t2 = new Token();
    String operador = "";
    String aux;
 }{
    ( <LOGICO_NOT> )* ( <VARIABLE> { //EXISTENCIA DE IDENTIFICADORES

                                    // Sino existe el id, lo guardamos en nuestra arreglo de errores
                                    if(!TablaIdentificadores.checkExistenciaId(token)){
                                        tabla.add("The indentifier: " + token.image + " doesn't exist, at line:" +
                                                    token.beginLine + " column:" + token.beginColumn);
                                    }else{
                                        t=token;
                                    }

}
    | t=constantes()
    | operacionParentesis() )

    (operador=operadores() ( <LOGICO_NOT> )* (<VARIABLE> {    //EXISTENCIA DE IDENTIFICADORES
                                                     // Sino existe el id, lo guardamos en nuestra arreglo de errores
                                                        if(!TablaIdentificadores.checkExistenciaId(token)){
                                                            tabla.add("The indentifier: " + token.image + " doesn't exist, at line:" +
                                                            token.beginLine + " column:" + token.beginColumn);
                                                        }else{
                                                            t=token;
                                                        }
}
    | t2=constantes()| operacionParentesis() ))*
    {
        //VERIFICAR ESTOS CAMBIOS **POSIBLE ERROR
        aux=GeneradorCodigo.operadoresAritmeticos(t.image, t2.image,operador); return t2;}
}

void operacionParentesis():{}{
    <PAREN_ABIERTO> operacion() <PAREN_CERRADO>
}

String operadores():{
    String operador;
 }{
    operador=operadoresAritmeticos() {return operador;}
    | operadoresLogicos() | operadoresRelacionales()

}

String operadoresAritmeticos():{}{
    <SUMA> {return token.image;}
    | <RESTA>{return token.image;}
    | <MULTIPLICACION>{return token.image;}
    | <DIVISION>{return token.image;}
    | <MODULO>{return token.image;}
}

void operadoresRelacionales():{}{
    <OPERADOR_IGUAL> | <OPERADOR_DIFERENTE> | <OPERADOR_MAYOR> | <OPERADOR_MAYOR_IGUAL> | <OPERADOR_MENOR> | <OPERADOR_MENOR_IGUAL>
}

void operadoresLogicos():{}{
    <LOGICO_AND> | <LOGICO_OR>
}

//DECLARACION DE VARIABLES:COMPROBACION DE TIPOS
void declaracionVariables():{
    Token identificador = new Token();
    Token asignado = new Token();
    String tipoDato = "";
 }{



    <DEFINIR>
    tipoDato=tiposDato()
    <VARIABLE> {
                        if(TablaIdentificadores.checkExistenciaId(token)){

                            tabla.add("The identifier: " + token.image + " already exist, at line: " + token.beginLine + " column:" + token.endColumn);
                        }else{
                            TablaIdentificadores.insertarIdentificadores(token,tipoDato);
                            identificador = token;
                        }
                    }

    (asignado=asignacion())? { //Se evalua si se esta asignando el tipo correcto al identificador
                    if(asignado.kind != 0){ //Comprobamos que el token asignado tenga un valor asociado y no sea nulo

                                  if(!TablaIdentificadores.verifiacionConToken(identificador,asignado)){
                                      tabla.add("The token: " + asignado.image + " doesn't correspond to the " +
                                        TablaIdentificadores.obtenerTipo(identificador) + " type");
                                  }
                          }
    }

}
String tiposDato():{ }{
    // Regresamos el patron que coincide con el token
    <ENTERO> {return token.image;}
    | <FLOTANTE> {return token.image;}
    | <CADENA> {return token.image;}
    |<CARACTER> {return token.image;}
    | <BOOLEANO> {return token.image;}
}

void leerDato():{}{
    try{
        <LEER> <VARIABLE> <DELIMITADOR>
    }catch(ParseException e){
        Token t;
        do{
            t=getNextToken();
        }while(t.kind != DELIMITADOR && t.kind != EOF);
        tabla.add("Parser error:" + e.getMessage());
    }

}

void imprimirDato():{}{
    //Modificar estructura
    try{
        LOOKAHEAD(3)<ESCRIBIR> <CADENA_TEXTO> <DELIMITADOR>
        |LOOKAHEAD(3)<ESCRIBIR><CADENA_TEXTO><COMA><VARIABLE><DELIMITADOR>
        |<ESCRIBIR><VARIABLE><DELIMITADOR>
    }catch(ParseException e){
        Token t;
        do{
            t=getNextToken();
        }while(t.kind != DELIMITADOR && t.kind != FIN);
        tabla.add("Parser error:" + e.getMessage());
    }

    //<ESCRIBIR> ( constantes() | <VARIABLE> ) <DELIMITADOR>
}

void sentenciaSi():{}{
    try{
        <INICIO_CONDICIONAL_SI> condicion() <ENTONCES> ( sentencias() )+
            ( <CONDICIONAL_SINO> ( sentencias() )+ )?
            <FIN_CONDICIONAL_SI>
    }catch(ParseException e){
        Token t;
        do{
            t=getNextToken();
        }while(t.kind != EOF);
        tabla.add("Parser error:" + e.getMessage());
    }

}



void sentenciaSegun():{}{

    <INICIO_CONDICIONAL_SEGUN> <VARIABLE> <HACER>
    ( <CASO> constantes() <OPERADOR_DOS_PUNTOS> ( sentencias() )+ )+
    ( <CASO_PREDETERMINADO> <OPERADOR_DOS_PUNTOS> ( sentencias() )+ )?
    <FIN_SEGUN>
}

//Ciclo for
void sentenciaPara():{}{


        <INICIO_CICLO_PARA><VARIABLE><ASIGNACION>( constantes() | <VARIABLE> )
            <CONDICION_CICLO_PARA> condicion() (<INCREMENTO_CICLO_PARA>|<DECREMENTO_CICLO_PARA>) ( <NUMERO_ENTERO> | <NUMERO_DECIMAL> )
            ( sentencias() )+
            <FIN_CICLO_PARA>


}
//Ciclo do while
void sentenciaRepetir():{}{

    <INICIO_CICLO_REPETIR> ( sentencias() )+
    <CONDICION_CICLO_REPETIR> condicion() <DELIMITADOR>
}
//Ciclo while
void sentenciaMientras():{}{

    <INICIO_CICLO_MIENTRAS> condicion() <HACER>
    ( sentencias() )+
    <FIN_CICLO_MIENTRAS>
}

