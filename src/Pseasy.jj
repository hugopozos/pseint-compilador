
options {
    STATIC = false;
    //**AGREGUE UNA OPCION QUE ME PERMITE NO TOMARLE IMPORTANCIA MAYUSCULAS Y MINUSCULAS
    IGNORE_CASE = true;
}

PARSER_BEGIN(Pseasy)
package src;
import java.util.ArrayList;
import java.io.*;
import src.TablaIdentificadores;
public class Pseasy {


        static ArrayList<String> tabla = PseasyTokenManager.tabla;

        //Arreglo para guardar lo generado por el codigo intermedio
        static ArrayList<String> codigoIntermedio = PseasyTokenManager.codigoIntermedio;

        //Variables para generacion de codigo intermedio
        private static int tmpContador = 0;
        static String tmpUltimaUtilizada = "";
        public static void main(String[] args) {
            try{
                Pseasy pseasy = new Pseasy(System.in);
                pseasy.programa();

                if(tabla.size() != 0){
                    System.out.println("PROGRAM ERRORS");
                    System.out.println("=================");
                    for(String i:tabla){
                        System.out.println(i);
                    }
                }else{
                    System.out.println("\ncompilation generated with success");
                    ArchivoCodigoIntermedio.escribirArchivo(codigoIntermedio);

                }
              }catch(Exception e){
                System.out.println(e.getMessage());
              }
          }

          //METODOS PARA LA GENERACION DE CODIGO INTERMEDIO
          private static void asignacion(String id, String exp){
            String tmp = id +" := " + exp + "\n";
            codigoIntermedio.add(tmp);
          }

          private static void operacionAritmetica(String op,String ex1, String ex2){
                tmpContador++;
                String aux = "tmp" + tmpContador;
                String cI = aux + "=" + ex1 + op + ex2;
                tmpUltimaUtilizada = aux;
                codigoIntermedio.add(cI);
          }
        }

 // ------------------------ GENERACION CODIGO INTERMEDIO -----------------------------


 //CLASE PARA ESCRIBIR EL CODIGO INTERMEDIO EN UN ARCHIVO
class ArchivoCodigoIntermedio {

    public static void escribirArchivo(ArrayList<String>codigoIntermedio){
        String fileName = "codigoIntermedio\\codigo_intermedio.txt";
        File archivo = new File(fileName);
        try{
            PrintWriter salida = new PrintWriter(archivo);
            for(String e:codigoIntermedio){
                salida.print(e);
            }
            salida.close();
        }catch(FileNotFoundException ex){
            System.out.println("No se encontro el archivo");
        }
    }
}

PARSER_END(Pseasy)

TOKEN_MGR_DECLS:{
    static ArrayList<String> tabla = new ArrayList();
    static ArrayList<String> codigoIntermedio = new ArrayList();
}

// Inicio y fin del programa
TOKEN : {
    <INICIO: "Algoritmo">
    |
    <FIN: "FinAlgoritmo">
}

// Tipos de dato
TOKEN : {

    <ENTERO: "entero">
    |
    <FLOTANTE:"flotante">
    |
    <CADENA:"cadena">
    |
    <BOOLEANO:"booleano">
}


// Constantes/Literales
TOKEN : {
    <#LETRA: ["a" - "z"] | ["A" - "Z"]>
    |
    <#NUMERO: ["0" - "9"]>
    |
    <CADENA_TEXTO: "\"" ( ~["\""] )* "\"">
    |
    <NUMERO_ENTERO:("-" | "" | "+")(<NUMERO>)+>
    |
    <NUMERO_DECIMAL: ("-" | "" | "+")(<NUMERO>)+"."(<NUMERO>)+>
    |
    <BOOLEANO_FALSO: "Falso">
    |
    <BOOLEANO_VERDADERO: "Verdadero">
    |
    <DELIMITADOR: ";">
    |
    <COMA:","> //Coma

}

// Escritura, Lectura y Definici√≥n de variables
TOKEN : {
    <LEER: "Leer">
    |
    <ESCRIBIR: "Escribir">
    |
    <DEFINIR: "Definir">
}

// Operadores
TOKEN : {
    <ASIGNACION: "=">
    |
    <SUMA: "+">
    |
    <RESTA: "-">
    |
    <MULTIPLICACION: "*">
    |
    <DIVISION: "/">
    |
    <MODULO: "%">
    |
    <LOGICO_AND: "&&">
    |
    <LOGICO_OR: "||">
    |
    <LOGICO_NOT: "!">
    |
    <OPERADOR_IGUAL: "==">
    |
    <OPERADOR_DIFERENTE: "!=">
    |
    <OPERADOR_MAYOR: ">">
    |
    <OPERADOR_MENOR: "<">
    |
    <OPERADOR_MAYOR_IGUAL: ">=">
    |
    <OPERADOR_MENOR_IGUAL: "<=">
    |
    <OPERADOR_DOS_PUNTOS: ":">
    |
    <PAREN_ABIERTO: "(">
    |
    <PAREN_CERRADO: ")">
}

// Ciclos
TOKEN : {
    <INICIO_CICLO_PARA: "Para">
    |
    <CONDICION_CICLO_PARA: "Hasta que">
    |
    <INCREMENTO_CICLO_PARA: "incremento">
    |
    <DECREMENTO_CICLO_PARA:"decremento">
    |
    <FIN_CICLO_PARA: "FinPara">
    |
    <INICIO_CICLO_MIENTRAS: "Mientras">
    |
    <FIN_CICLO_MIENTRAS: "FinMientras">
    |
    <INICIO_CICLO_REPETIR: "Repetir">
    |
    <CONDICION_CICLO_REPETIR: "Finaliza cuando">
}

// Condicionales
TOKEN : {
    <INICIO_CONDICIONAL_SI:"Si">
    |
    <ENTONCES:"Entonces">
    |
    <CONDICIONAL_SINO:"Sino">
    |
    <FIN_CONDICIONAL_SI:"FinSi">
    |
    <INICIO_CONDICIONAL_SEGUN:"Segun">
    |
    <CASO:"Caso">
    |
    <CASO_PREDETERMINADO:"En otro caso">
    |
    <FIN_SEGUN:"FinSegun">
    |
    <HACER : "Hacer">
}

//Variables
TOKEN : {
    <VARIABLE:(<LETRA> | "_")(<NUMERO> | <LETRA> | "_")*>
    /*
    * IDENTIFICADORES NO VALIDOS
    * */
}

SKIP : {
    " "
    | "\t"
    | "\r\n"
    | "\n"
    | <COMENTARIO: "#" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
    //Tokens invalidos
    |<ID_INVALIDO:(<NUMERO>)+(<LETRA>|<NUMERO>)+>{tabla.add("Lexical error at line:" + input_stream.getBeginLine() + " column:" + input_stream.getBeginColumn() +
                                                                     " invalid id:" + image);}
    | <INVALIDO: ~[]>{tabla.add("Lexical error at line:" + input_stream.getBeginLine() + " column:" + input_stream.getBeginColumn() +
                    "invalid token:" + image);}
}

// Gramaticas

//CAMBIO: Nuestro programa puede no tener sentencias entre Algoritmo y FinAlgoritmo
void programa(): { }{

       try{
          <INICIO>
          ( sentencias() )*
          <FIN>{//TablaIdentificadores.mostrarTabla();
       }
       }catch(ParseException e){
            Token t;
            do{
                t=getNextToken();
            }while(t.kind != EOF);


            tabla.add("Parser Error:" + e.getMessage());
       }

}

void sentencias():{
    TablaIdentificadores.inicializarTipos();
 }{

            sentenciaAsignacion() |
            sentenciaDeclaracionVariables() |
            leerDato() |
            imprimirDato() |
            sentenciaSi() |
            sentenciaSegun() |
            sentenciaPara() |
            sentenciaRepetir() |
            sentenciaMientras()



}
//ASIGNACION DE VALOR
//CAMBIAR FORMA EN COMO SE HACE LA C
void sentenciaAsignacion():{
    String identificador = null;
    String asignado = null;
 }{
    try{

        <VARIABLE> {
                        //EXISTENCIA DE IDENTIFICADORES
                        // Sino existe el id, lo guardamos en nuestra arreglo de errores
                        //System.out.println("Token:" + token);
                         if(!TablaIdentificadores.checkExistenciaId(token.image)){
                               tabla.add("The indentifier: " + token.image + " doesn't exist, at line:" +
                                       token.beginLine + " column:" + token.beginColumn);
                         }else{
                            identificador = token.image;

                         }
        }
        asignado=asignacion() { //Se evalua si se esta asignando el tipo correcto al identificador

                        //--- PARTE SEMANTICA: COMPROBACION DE TIPOS
                        if(asignado != null && identificador !=null){
                                  //Si asignado e identificador tienen un valor asignado, se comprueban que sean del mismo tipo
                                if(!TablaIdentificadores.verifiacionConToken(identificador,asignado)){

                                    tabla.add("The token: " + asignado + " doesn't correspond to the " +
                                            TablaIdentificadores.obtenerTipoidentificador(identificador) + " type");

                                // ----- GENERACION CODIGO INTERMEDIO
                                //Si esta bien semanticamente, lo pasamos a codigo intermedio
                                }else{
                                    asignacion(identificador,asignado);
                                }

                        }


        }
        <DELIMITADOR>

    }catch(ParseException e){
        //System.out.println(e.toString());
        Token t;
        do{
            t=getNextToken();
        }while(t.kind != DELIMITADOR && t.kind != EOF);
        tabla.add("Parser error:" + e.getMessage());
    }
}

//Probar manejo de errores
void sentenciaDeclaracionVariables():{}{
    try{
        (declaracionVariables() <DELIMITADOR>)

    }catch(ParseException e){
            //System.out.println(e.toString());
            Token t;
            do{
                t=getNextToken();
                //VERIFICAR ERROR DE PUNTO Y COMA AL FINAL
            }while(t.kind != DELIMITADOR && t.kind != EOF);
            tabla.add("Parser error:" + e.getMessage());
    }
}


//CAMBIAMOS el tipo de dato retornado a token
String constantes():{ }{
    <NUMERO_ENTERO> {return token.image;}
    | <NUMERO_DECIMAL>  {return token.image;}
    | <CADENA_TEXTO> {return token.image;}
    | <BOOLEANO_FALSO> {return token.image;}
    | <BOOLEANO_VERDADERO> {return token.image;}
}

//ASIGNACION CORRECTA DE VALORES
String asignacion():{String asignado = "";}{
     <ASIGNACION> asignado=condicion() {return asignado;}
}

String condicion():{String asignado = "";} {
    asignado=operacion() {return asignado;}
    ( operadoresRelacionales() operacion() )*
}


String operacion():{
    String t = "";
 }{
    ( <LOGICO_NOT> )* ( <VARIABLE> { //EXISTENCIA DE IDENTIFICADORES

                                    // Sino existe el id, lo guardamos en nuestra arreglo de errores
                                    if(!TablaIdentificadores.checkExistenciaId(token.image)){
                                        tabla.add("The indentifier: " + token.image + " doesn't exist, at line:" +
                                                    token.beginLine + " column:" + token.beginColumn);
                                    }else{
                                        t=token.image;
                                    }

}
    | t=constantes()
    | operacionParentesis() )

    (operadores() ( <LOGICO_NOT> )* (<VARIABLE> {    //EXISTENCIA DE IDENTIFICADORES
                                                     // Sino existe el id, lo guardamos en nuestra arreglo de errores
                                                        if(!TablaIdentificadores.checkExistenciaId(token.image)){
                                                            tabla.add("The indentifier: " + token.image + " doesn't exist, at line:" +
                                                            token.beginLine + " column:" + token.beginColumn);
                                                        }else{
                                                            t=token.image;
                                                        }
}
    | t=constantes()| operacionParentesis() ))*
    {return t;}
}

void operacionParentesis():{}{
    <PAREN_ABIERTO> operacion() <PAREN_CERRADO>
}

void operadores():{}{
    operadoresAritmeticos() | operadoresLogicos() | operadoresRelacionales()
}

void operadoresAritmeticos():{}{
    <SUMA> | <RESTA> | <MULTIPLICACION> | <DIVISION> | <MODULO>
}

void operadoresRelacionales():{}{
    <OPERADOR_IGUAL> | <OPERADOR_DIFERENTE> | <OPERADOR_MAYOR> | <OPERADOR_MAYOR_IGUAL> | <OPERADOR_MENOR> | <OPERADOR_MENOR_IGUAL>
}

void operadoresLogicos():{}{
    <LOGICO_AND> | <LOGICO_OR>
}

//DECLARACION DE VARIABLES:COMPROBACION DE TIPOS
void declaracionVariables():{
    String identificador = "";
    String asignado = "";
    String tipoDato = "";
 }{



    <DEFINIR>
    tipoDato=tiposDato()
    <VARIABLE> {
                        if(TablaIdentificadores.checkExistenciaId(token.image)){

                            tabla.add("The identifier: " + token.image + " already exist, at line: " + token.beginLine + " column:" + token.endColumn);
                        }else{
                            TablaIdentificadores.insertarIdentificadores(token.image,tipoDato);
                            identificador = token.image;
                        }
                    }

    (asignado=asignacion())? { //Se evalua si se esta asignando el tipo correcto al identificador
                    if(!asignado.equals("")){ //Comprobamos que el token asignado tenga un valor asociado y no sea nulo
                        System.out.println("asignado =" + asignado);
                                  if(!TablaIdentificadores.verifiacionConToken(identificador,asignado)){
                                      tabla.add("The token: " + asignado + " doesn't correspond to the " +
                                        TablaIdentificadores.obtenerTipoidentificador(identificador) + " type");
                                  }
                          }
    }

}
String tiposDato():{ }{
    // Regresamos el patron que coincide con el token
    <ENTERO> {return token.image;}
    | <FLOTANTE> {return token.image;}
    | <CADENA> {return token.image;}
    | <BOOLEANO> {return token.image;}
}

void leerDato():{}{
    try{
        <LEER> <VARIABLE> <DELIMITADOR>
    }catch(ParseException e){
        Token t;
        do{
            t=getNextToken();
        }while(t.kind != DELIMITADOR && t.kind != EOF);
        tabla.add("Parser error:" + e.getMessage());
    }

}

void imprimirDato():{}{
    //Modificar estructura
    try{
        LOOKAHEAD(3)<ESCRIBIR> <CADENA_TEXTO> <DELIMITADOR>
        |LOOKAHEAD(3)<ESCRIBIR><CADENA_TEXTO><COMA><VARIABLE><DELIMITADOR>
        |<ESCRIBIR><VARIABLE><DELIMITADOR>
    }catch(ParseException e){
        Token t;
        do{
            t=getNextToken();
        }while(t.kind != DELIMITADOR && t.kind != FIN);
        tabla.add("Parser error:" + e.getMessage());
    }

    //<ESCRIBIR> ( constantes() | <VARIABLE> ) <DELIMITADOR>
}

void sentenciaSi():{}{
    try{
        <INICIO_CONDICIONAL_SI> condicion() <ENTONCES> ( sentencias() )+
            ( <CONDICIONAL_SINO> ( sentencias() )+ )?
            <FIN_CONDICIONAL_SI>
    }catch(ParseException e){
        Token t;
        do{
            t=getNextToken();
        }while(t.kind != EOF);
        tabla.add("Parser error:" + e.getMessage());
    }

}



void sentenciaSegun():{}{

    <INICIO_CONDICIONAL_SEGUN> <VARIABLE> <HACER>
    ( <CASO> constantes() <OPERADOR_DOS_PUNTOS> ( sentencias() )+ )+
    ( <CASO_PREDETERMINADO> <OPERADOR_DOS_PUNTOS> ( sentencias() )+ )?
    <FIN_SEGUN>
}

//Ciclo for
void sentenciaPara():{}{


        <INICIO_CICLO_PARA><VARIABLE><ASIGNACION>( constantes() | <VARIABLE> )
            <CONDICION_CICLO_PARA> condicion() (<INCREMENTO_CICLO_PARA>|<DECREMENTO_CICLO_PARA>) ( <NUMERO_ENTERO> | <NUMERO_DECIMAL> )
            ( sentencias() )+
            <FIN_CICLO_PARA>


}
//Ciclo do while
void sentenciaRepetir():{}{

    <INICIO_CICLO_REPETIR> ( sentencias() )+
    <CONDICION_CICLO_REPETIR> condicion() <DELIMITADOR>
}
//Ciclo while
void sentenciaMientras():{}{

    <INICIO_CICLO_MIENTRAS> condicion() <HACER>
    ( sentencias() )+
    <FIN_CICLO_MIENTRAS>
}
/*
* ELEMENTOS QUE ELIMINE
* EL TIPO DE DATO CARACTER
* LA ASIGNACION COMPUESTA 
*
* */
