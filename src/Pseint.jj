
options {
    STATIC = false;
    //**AGREGUE UNA OPCION QUE ME PERMITE NO TOMARLE IMPORTANCIA MAYUSCULAS Y MINUSCULAS
    IGNORE_CASE = true;
}

PARSER_BEGIN(Pseint)
package src;
import java.util.ArrayList;
import src.TablaIdentificadores;
public class Pseint {

        static ArrayList<String> tabla = PseintTokenManager.tabla;
        public static void main(String[] args) {
            try{
                Pseint pseint = new Pseint(System.in);
                pseint.programa();

                if(tabla.size() != 0){
                    System.out.println("ERRORES PROGRAMA");
                    System.out.println("=================");
                    for(String i:tabla){
                        System.out.println(i);
                    }
                }else{
                    System.out.println("\nCompilacion completada con exito");

                }
              }catch(Exception e){
                System.out.println(e.getMessage());
              }
          }
        }
PARSER_END(Pseint)

TOKEN_MGR_DECLS:{
    static ArrayList<String> tabla = new ArrayList();
}

// Inicio y fin del programa
TOKEN : {
    <INICIO: "Algoritmo">
    |
    <FIN: "FinAlgoritmo">
}

// Tipos de dato
TOKEN : {

    <ENTERO: "entero">
    |
    <FLOTANTE:"flotante">
    |
    <CADENA:"cadena">
    |
    <CARACTER:"caracter">
    |
    <BOOLEANO:"booleano">
}


// Constantes/Literales
TOKEN : {
    <#LETRA: ["a" - "z"] | ["A" - "Z"]>
    |
    <#NUMERO: ["0" - "9"]>
    |
    <CADENA_TEXTO: "\"" ( ~["\""] )* "\"">
    |
    <CARACTER_TEXTO: "'"( ~["'"] | "" )"'">
    |
    <NUMERO_ENTERO:(<NUMERO>)+>
    |
    <NUMERO_DECIMAL: ("-" | "" | "+")(<NUMERO>)+"."(<NUMERO>)+>
    |
    <BOOLEANO_FALSO: "Falso">
    |
    <BOOLEANO_VERDADERO: "Verdadero">
    |
    <DELIMITADOR: ";">
    |
    <COMA:","> //Coma

}

// Escritura, Lectura y Definici√≥n de variables
TOKEN : {
    <LEER: "Leer">
    |
    <ESCRIBIR: "Escribir">
    |
    <DEFINIR: "Definir">
}

// Operadores
TOKEN : {
    <ASIGNACION: "=">
    |
    <SUMA: "+">
    |
    <RESTA: "-">
    |
    <MULTIPLICACION: "*">
    |
    <DIVISION: "/">
    |
    <MODULO: "%">
    |
    <LOGICO_AND: "&&">
    |
    <LOGICO_OR: "||">
    |
    <LOGICO_NOT: "!">
    |
    <ASIGNACION_COMPUESTA: (<SUMA>|<RESTA>|<MULTIPLICACION>|<DIVISION>|<MODULO>|<LOGICO_AND>|<LOGICO_OR>)<ASIGNACION>>
    |
    <OPERADOR_IGUAL: "==">
    |
    <OPERADOR_DIFERENTE: "!=">
    |
    <OPERADOR_MAYOR: ">">
    |
    <OPERADOR_MENOR: "<">
    |
    <OPERADOR_MAYOR_IGUAL: ">=">
    |
    <OPERADOR_MENOR_IGUAL: "<=">
    |
    <OPERADOR_DOS_PUNTOS: ":">
    |
    <PAREN_ABIERTO: "(">
    |
    <PAREN_CERRADO: ")">
}

// Ciclos
TOKEN : {
    <INICIO_CICLO_PARA: "Para">
    |
    <CONDICION_CICLO_PARA: "Hasta que">
    |
    <INCREMENTO_CICLO_PARA: "incremento">
    |
    <DECREMENTO_CICLO_PARA:"decremento">
    |
    <FIN_CICLO_PARA: "FinPara">
    |
    <INICIO_CICLO_MIENTRAS: "Mientras">
    |
    <FIN_CICLO_MIENTRAS: "FinMientras">
    |
    <INICIO_CICLO_REPETIR: "Repetir">
    |
    <CONDICION_CICLO_REPETIR: "Finaliza cuando">
}

// Condicionales
TOKEN : {
    <INICIO_CONDICIONAL_SI:"Si">
    |
    <ENTONCES:"Entonces">
    |
    <CONDICIONAL_SINO:"Sino">
    |
    <FIN_CONDICIONAL_SI:"FinSi">
    |
    <INICIO_CONDICIONAL_SEGUN:"Segun">
    |
    <CASO:"Caso">
    |
    <CASO_PREDETERMINADO:"En otro caso">
    |
    <FIN_SEGUN:"FinSegun">
    |
    <HACER : "Hacer">
}

//Variables
TOKEN : {
    <VARIABLE:(<LETRA> | "_")(<NUMERO> | <LETRA> | "_")*>
    /*
    * IDENTIFICADORES NO VALIDOS
    * */
}

SKIP : {
    " "
    | "\t"
    | "\r\n"
    | "\n"
    | <COMENTARIO: "#" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
    //Tokens invalidos
    |<ID_INVALIDO:(<NUMERO>)+(<LETRA>|<NUMERO>)+>{tabla.add("Lexical error at line:" + input_stream.getBeginLine() + " column:" + input_stream.getBeginColumn() +
                                                                     " invalid id:" + image);}
    | <INVALIDO: ~[]>{tabla.add("Lexical error at line:" + input_stream.getBeginLine() + " column:" + input_stream.getBeginColumn() +
                    "invalid token:" + image);}
}

// Gramaticas

//CAMBIO: Nuestro programa puede no tener sentencias entre Algoritmo y FinAlgoritmo
void programa(): { }{

       try{
          <INICIO>
          ( sentencias() )*
          <FIN>{TablaIdentificadores.mostrarTabla();
       }
       }catch(ParseException e){
            Token t;
            do{
                t=getNextToken();
            }while(t.kind != EOF);
            tabla.add("Parser Error:" + e.getMessage());
       }

}

void sentencias():{
    TablaIdentificadores.inicializarTipos();
 }{
            sentenciaAsignacion() |
            sentenciaDeclaracionVariables() |
            leerDato() |
            imprimirDato() |
            sentenciaSi() |
            sentenciaSegun() |
            sentenciaPara() |
            sentenciaRepetir() |
            sentenciaMientras()

}
//ASIGNACION DE VALOR
//Aqui hay un problema
void sentenciaAsignacion():{
    Token identificador = new Token();
    Token asignado = new Token();
 }{
    try{


    <VARIABLE> {
                    //EXISTENCIA DE IDENTIFICADORES
                    // Sino existe el id, lo guardamos en nuestra arreglo de errores
                     if(!TablaIdentificadores.checkExistenciaId(token)){
                           tabla.add("The indentifier: " + token.image + " doesn't exist, at line:" +
                                   token.beginLine + " column:" + token.beginColumn);
                     }else{
                        identificador = token;
                     }
    }
    asignado=asignacion() { //Se evalua si se esta asignando el tipo correcto al identificador
                       //System.out.println("identificador: " + identificador.image);
                       //System.out.println("asignado: " + asignado.image);
                      if(!TablaIdentificadores.verifiacionConToken(identificador,asignado)){
                                tabla.add("The token: " + asignado.image + " doesn't correspond to the:" +
                                            TablaIdentificadores.obtenerTipo(identificador) + " type");
                          }
    }
    <DELIMITADOR>

    }catch(ParseException e){
        //System.out.println(e.toString());
        Token t;
        do{
            t=getNextToken();
        }while(t.kind != DELIMITADOR);
        tabla.add("Parser error:" + e.getMessage());
    }
}

//Probar manejo de errores
void sentenciaDeclaracionVariables():{}{
    try{
        (declaracionVariables() <DELIMITADOR>)

    }catch(ParseException e){
            //System.out.println(e.toString());
            Token t;
            do{
                t=getNextToken();
                //VERIFICAR ERROR DE PUNTO Y COMA AL FINAL
            }while(t.kind != DELIMITADOR);
            tabla.add("Parser error:" + e.getMessage());
    }
}


//CAMBIAMOS el tipo de dato retornado a token
Token constantes():{ }{
    <NUMERO_ENTERO> {return token;}
    | <NUMERO_DECIMAL>  {return token;}
    | <CADENA_TEXTO> {return token;}
    | <CARACTER_TEXTO> {return token;}
    | <BOOLEANO_FALSO> {return token;}
    | <BOOLEANO_VERDADERO> {return token;}
}

//ASIGNACION CORRECTA DE VALORES
Token asignacion():{Token asignado = new Token();}{
    ( <ASIGNACION> | <ASIGNACION_COMPUESTA> ) asignado=condicion() {return asignado;}
}

Token condicion():{Token asignado = new Token();} {
    asignado=operacion() {return asignado;}
    ( operadoresRelacionales() operacion() )*
}


Token operacion():{
    Token t = new Token();
 }{
    ( <LOGICO_NOT> )* ( <VARIABLE> { //EXISTENCIA DE IDENTIFICADORES
                                    // Sino existe el id, lo guardamos en nuestra arreglo de errores
                                    if(!TablaIdentificadores.checkExistenciaId(token)){
                                        tabla.add("The indentifier: " + token.image + " doesn't exist, at line:" +
                                                    token.beginLine + " column:" + token.beginColumn);
                                    }else{
                                        t=token;
                                    }

}
    | t=constantes()
    | operacionParentesis() )

    (operadores() ( <LOGICO_NOT> )* (<VARIABLE> {    //EXISTENCIA DE IDENTIFICADORES
                                                     // Sino existe el id, lo guardamos en nuestra arreglo de errores
                                                        if(!TablaIdentificadores.checkExistenciaId(token)){
                                                            tabla.add("The indentifier: " + token.image + " doesn't exist, at line:" +
                                                            token.beginLine + " column:" + token.beginColumn);
                                                        }
}
    | t=constantes()| operacionParentesis() ))*
    {return t;}
}

void operacionParentesis():{}{
    <PAREN_ABIERTO> operacion() <PAREN_CERRADO>
}

void operadores():{}{
    operadoresAritmeticos() | operadoresLogicos() | operadoresRelacionales()
}

void operadoresAritmeticos():{}{
    <SUMA> | <RESTA> | <MULTIPLICACION> | <DIVISION> | <MODULO>
}

void operadoresRelacionales():{}{
    <OPERADOR_IGUAL> | <OPERADOR_DIFERENTE> | <OPERADOR_MAYOR> | <OPERADOR_MAYOR_IGUAL> | <OPERADOR_MENOR> | <OPERADOR_MENOR_IGUAL>
}

void operadoresLogicos():{}{
    <LOGICO_AND> | <LOGICO_OR>
}

//DECLARACION DE VARIABLES:COMPROBACION DE TIPOS
void declaracionVariables():{
    Token identificador = new Token();
    Token asignado = new Token();
    String tipoDato = "";
 }{
    <DEFINIR>
    tipoDato=tiposDato()
    <VARIABLE> {
                        if(TablaIdentificadores.checkExistenciaId(token)){
                            System.out.println("Ya existe el token: " + token.image);
                            tabla.add("The identifier: " + token.image + " already exist, at line: " + token.beginLine + " column:" + token.endColumn);
                        }else{
                            TablaIdentificadores.insertarIdentificadores(token,tipoDato);
                            identificador = token;
                        }
                    }

    (asignado=asignacion())? { //Se evavlua si se esta asignando el tipo correcto al identificador
                    if(asignado.kind != 0){
                              System.out.println("identificador: " + identificador.image);
                              System.out.println("asignado: " + asignado.image);
                                  if(!TablaIdentificadores.verifiacionConToken(identificador,asignado)){
                                      tabla.add("The token: " + asignado.image + " doesn't correspond to the:" +
                                        TablaIdentificadores.obtenerTipo(identificador) + " type");
                                  }
                          }
}
}
String tiposDato():{ }{
    // Regresamos el patron que coincide con el token
    <ENTERO> {return token.image;}
    | <FLOTANTE> {return token.image;}
    | <CADENA> {return token.image;}
    |<CARACTER> {return token.image;}
    | <BOOLEANO> {return token.image;}
}

void leerDato():{}{

    <LEER> <VARIABLE> <DELIMITADOR>
}

void imprimirDato():{}{
    //Modificar estructura
    LOOKAHEAD(3)<ESCRIBIR> <CADENA_TEXTO> <DELIMITADOR>
    |LOOKAHEAD(3)<ESCRIBIR><CADENA_TEXTO><COMA><VARIABLE><DELIMITADOR>
    |<ESCRIBIR><VARIABLE><DELIMITADOR>
    //<ESCRIBIR> ( constantes() | <VARIABLE> ) <DELIMITADOR>
}

void sentenciaSi():{}{
    try{
        <INICIO_CONDICIONAL_SI> condicion() <ENTONCES> ( sentencias() )+
            ( <CONDICIONAL_SINO> ( sentencias() )+ )?
            <FIN_CONDICIONAL_SI>
    }catch(ParseException e){
        Token t;
        do{
            t=getNextToken();
        }while(t.kind != FIN_CONDICIONAL_SI);
        tabla.add("Parser error:" + e.getMessage());
    }

}



void sentenciaSegun():{}{

    <INICIO_CONDICIONAL_SEGUN> <VARIABLE> <HACER>
    ( <CASO> constantes() <OPERADOR_DOS_PUNTOS> ( sentencias() )+ )+
    ( <CASO_PREDETERMINADO> <OPERADOR_DOS_PUNTOS> ( sentencias() )+ )?
    <FIN_SEGUN>
}

//Ciclo for
void sentenciaPara():{}{
    try{
        <INICIO_CICLO_PARA><VARIABLE><ASIGNACION>( constantes() | <VARIABLE> )
            <CONDICION_CICLO_PARA> condicion() (<INCREMENTO_CICLO_PARA>|<DECREMENTO_CICLO_PARA>) ( <NUMERO_ENTERO> | <NUMERO_DECIMAL> )
            ( sentencias() )+
            <FIN_CICLO_PARA>
    }catch(ParseException e){
        Token t;
        do{
            t=getNextToken();
        }while(t.kind != FIN); //FIN_CICLO_PARA.kind = 44
        tabla.add("Parser error:" + e.getMessage());
    }

}
//Ciclo while
void sentenciaRepetir():{}{

    <INICIO_CICLO_REPETIR> ( sentencias() )+
    <CONDICION_CICLO_REPETIR> condicion() <DELIMITADOR>
}
//Ciclo do while
void sentenciaMientras():{}{

    <INICIO_CICLO_MIENTRAS> condicion() <HACER>
    ( sentencias() )+
    <FIN_CICLO_MIENTRAS>
}

